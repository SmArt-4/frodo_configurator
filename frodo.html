<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="google" content="notranslate">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frodo Configurator</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#007bff">
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(() => console.log('Service Worker Registered (Offline Capable)'))
                .catch((error) => console.log('SW Registration Failed:', error));
        }
    </script>
    <style>
        :root {
            /* Light theme defaults */
            --bg-color: #f7f7f9;
            --panel-bg: #ffffff;
            --border-color: #d9d9e0;
            --highlight: #007bff;
            --text-color: #1f2328;
            --muted-bg: #eef0f3;
            --muted-fg: #57606a;
            --frame-bg: #fafafa;
            --frame-border: #d0d7de;
            --ruler-tick: #8c959f;
            --ruler-text: #6e7781;
            --baseline-color: #d8dee4;
            --vtx1-color: #007bff; /* Blue */
            --vtx2-color: #28a745; /* Green */
            --error-color: #dc3545;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #0d1117;
                --panel-bg: #161b22;
                --border-color: #30363d;
                --highlight: #2f81f7;
                --text-color: #e6edf3;
                --muted-bg: #1f242d;
                --muted-fg: #9ea7b3;
                --frame-bg: #11161d;
                --frame-border: #30363d;
                --ruler-tick: #6e7681;
                --ruler-text: #9ea7b3;
                --baseline-color: #2d333b;
            }
        }

        html[data-theme="light"] {
            --bg-color: #f7f7f9;
            --panel-bg: #ffffff;
            --border-color: #d9d9e0;
            --highlight: #007bff;
            --text-color: #1f2328;
            --muted-bg: #eef0f3;
            --muted-fg: #57606a;
            --frame-bg: #fafafa;
            --frame-border: #d0d7de;
            --ruler-tick: #8c959f;
            --ruler-text: #6e7781;
            --baseline-color: #d8dee4;
        }
        html[data-theme="dark"] {
            --bg-color: #0d1117;
            --panel-bg: #161b22;
            --border-color: #30363d;
            --highlight: #2f81f7;
            --text-color: #e6edf3;
            --muted-bg: #1f242d;
            --muted-fg: #9ea7b3;
            --frame-bg: #11161d;
            --frame-border: #30363d;
            --ruler-tick: #6e7681;
            --ruler-text: #9ea7b3;
            --baseline-color: #2d333b;
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background: var(--bg-color); 
            color: var(--text-color); 
            margin: 0 auto; 
            padding: 20px; 
            max-width: 900px; 
        }
        
        /* HEADER */
        .header {
            display: flex; flex-direction: row; justify-content: space-between; align-items: center;
            gap: 15px; background: var(--panel-bg); padding: 10px 15px; 
            border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); margin-bottom: 20px;
            flex-wrap: nowrap;
        }
        
        .header-group { display: flex; align-items: center; gap: 10px; }
        
        label { font-weight: 600; font-size: 14px; margin-right: 5px; white-space: nowrap; }
        
        .commit-hash {
            font-family: monospace; background: var(--muted-bg); padding: 6px 8px; 
            border-radius: 6px; border: 1px solid var(--border-color); color: var(--muted-fg); font-size: 13px;
        }

        /* INPUTS & BUTTONS */
        select, input[type="text"], input[type="number"] {
            padding: 6px 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 14px;
        }
        
        button {
            padding: 8px 16px; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; transition: 0.2s;
            font-size: 14px; white-space: nowrap;
        }
        #connectBtn { background-color: var(--highlight); color: white; }
        #connectBtn.connected { background-color: #28a745; }

        .btn-green { background-color: #28a745; color: #fff; }
        .btn-blue { background-color: var(--highlight); color: #fff; }
        .text-right { text-align: right; }

        /* Split Button */
        .split { position: relative; display: inline-flex; --caret-w: 36px; }
        .btn-main { border-radius: 4px 0 0 4px; }
        .btn-caret {
            border-radius: 0 4px 4px 0; padding: 8px 10px; width: var(--caret-w);
            display: flex; align-items: center; justify-content: center;
            border-left: 1px solid rgba(255,255,255,0.6);
        }
        .dropdown-row {
            position: absolute; top: calc(100% + 6px); left: 0;
            min-width: calc(100% - var(--caret-w)); width: max-content;
            display: none; z-index: 20;
        }
        .dropdown-row.show { display: block; }
        .dropdown-row .btn-blue {
            border-radius: 4px; padding: 8px 12px; white-space: nowrap; display: block;
            box-shadow: 0 3px 8px rgba(0,0,0,0.08); margin-bottom: 6px;
        }
        .dropdown-row .btn-blue:last-child { margin-bottom: 0; }
        
        /* SETTINGS GRID */
        .settings-block {
            border: 2px solid var(--border-color); background: var(--panel-bg);
            padding: 25px 20px 20px 20px; border-radius: 5px; margin-bottom: 20px; position: relative;
        }
        .settings-block h3 {
            position: absolute; top: -12px; left: 15px; background: var(--panel-bg);
            padding: 0 10px; margin: 0; color: #555; font-size: 16px;
        }

        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; }
        @media (max-width: 600px) {
            .settings-grid { grid-template-columns: 1fr; gap: 10px; }
            .header { overflow-x: auto; }
        }
        
        /* FORM ROWS */
        .form-row { 
            display: flex; 
            flex-direction: row; 
            align-items: center; 
            margin-bottom: 12px; 
        }
        .form-row label { 
            width: 120px; 
            margin-bottom: 0; 
            flex-shrink: 0; 
            font-size: 13px; color: #666; 
        }
        .form-row input, .form-row select { 
            flex-grow: 1; 
            width: auto;
        }

        /* FREQ BLOCK */
        .freq-block { padding: 10px 0; position: relative; }
        .freq-block h3 { margin: 0 0 15px 0; color: #555; font-size: 16px; border-bottom: 1px solid #eee; display: inline-block;}
        .range-inputs { display: flex; align-items: center; gap: 10px; flex-grow: 1; }
        .range-inputs input { width: 80px; text-align: center; }

        /* VISUALIZER CANVAS */
        .viz-container {
            position: relative; 
            width: 95%; 
            margin: 15px auto 25px auto; 
            height: 70px; /* Taller to fit text below */
            background: transparent; /* No background here, we draw it in canvas */
            border: none; /* Remove HTML border */
            border-radius: 0; 
            cursor: crosshair;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* POPUP */
        .freq-popup {
            position: absolute; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 4px;
            padding: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.25);
            z-index: 100; display: none; transform: translate(-50%, -100%); margin-top: -10px;
            text-align: center; min-width: 120px; color: var(--text-color);
        }
        .freq-popup::after { 
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -6px;
            border-width: 6px; border-style: solid; border-color: var(--panel-bg) transparent transparent transparent;
        }
        .freq-popup::before { 
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -7px;
            border-width: 7px; border-style: solid; border-color: var(--border-color) transparent transparent transparent; z-index: -1;
        }
        .freq-label { font-weight: bold; margin-bottom: 5px; font-size: 14px; display: block; }
        .popup-btns { display: flex; gap: 5px; justify-content: center; }
        .btn-mini { padding: 4px 8px; font-size: 11px; border-radius: 3px; border: none; cursor: pointer; color: white;}
        .btn-vtx1 { background-color: var(--vtx1-color); opacity: 0.5; }
        .btn-vtx1.active { opacity: 1; border: 2px solid #004085; }
        .btn-vtx2 { background-color: var(--vtx2-color); opacity: 0.5; }
        .btn-vtx2.active { opacity: 1; border: 2px solid #1e7e34; }

        /* RANDOM GENERATOR POPUP */
        .overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; z-index: 200;
        }
        .overlay.show { display: block; }
        .rand-popup {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: min(560px, 95vw);
            box-shadow: 0 10px 30px rgba(0,0,0,0.25); z-index: 201; display: none; color: var(--text-color);
        }
        .rand-popup.show { display: block; }
        .rand-header { padding: 12px 14px; font-weight: 700; border-bottom: 1px solid var(--border-color); display:flex; justify-content: space-between; align-items:center; color: var(--text-color); }
        .rand-body { padding: 12px 14px; display: grid; gap: 10px; color: var(--text-color); }
        .rand-row { display: flex; align-items: center; gap: 10px; }
        .rand-row label { width: 160px; color: var(--muted-fg); font-weight: 600; }
        .rand-row .grow { flex: 1; }
        .rand-footer { padding: 12px 14px; border-top: 1px solid var(--border-color); display: flex; gap: 8px; justify-content: flex-end; }
        .rand-textarea { width: 100%; min-height: 56px; resize: vertical; font-family: monospace; font-size: 12px; background: var(--panel-bg); color: var(--text-color); border: 1px solid var(--border-color); }
        .rand-note { font-size: 12px; color: var(--muted-fg); }

        /* Help modal text/readability */
        .rand-body p { margin: 0 0 8px 0; color: var(--text-color); }
        .rand-body details { border: 1px solid var(--border-color); border-radius: 6px; background: var(--panel-bg); }
        .rand-body details + details { margin-top: 8px; }
        .rand-body details[open] { background: var(--panel-bg); }
        .rand-body summary { list-style: none; cursor: pointer; padding: 10px 12px; color: var(--text-color); }
        .rand-body summary::-webkit-details-marker { display: none; }
        .rand-body summary:before { content: '▸'; display: inline-block; margin-right: 6px; transform: rotate(0deg); transition: transform 0.15s ease; color: var(--muted-fg); }
        .rand-body details[open] > summary:before { transform: rotate(90deg); }
        .rand-body code { background: var(--muted-bg); color: var(--text-color); border: 1px solid var(--border-color); padding: 0 4px; border-radius: 4px; }

        /* Inputs inside modals respect theme */
        .rand-body input[type="text"],
        .rand-body input[type="number"],
        .rand-body select {
            background: var(--panel-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        /* Override inline close button color in header for theme */
        .rand-header button {
            background: var(--muted-bg) !important;
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        /* VTX RICH INPUT STYLES */
        .vtx-wrapper { position: relative; flex-grow: 1; display: flex; }
        
        .vtx-input { 
            display: none; width: 100%; 
            box-sizing: border-box; padding: 6px 8px; 
            border: 1px solid var(--border-color); border-radius: 4px; 
            font-size: 14px; margin: 0; height: 35px;
        } 
        .vtx-input.active { display: block; }
        
        .vtx-display {
            width: 100%; box-sizing: border-box;
            padding: 6px 8px; border: 1px solid var(--border-color); border-radius: 4px; 
            font-size: 14px; background: #fff; min-height: 35px; 
            display: flex; flex-wrap: wrap; gap: 5px; align-items: center; cursor: text;
        }
        .vtx-display.hidden { display: none; }
        
        .freq-tag { color: #333; }
        .freq-tag.out-range { 
            color: var(--error-color); 
            text-decoration: underline; text-decoration-thickness: 2px; font-weight: bold;
        }
        .freq-tag.placeholder { color: #aaa; font-style: italic; }

        /* LOG WINDOW */
        #debugLog {
            margin-top: 20px; font-family: monospace; font-size: 11px; color: var(--muted-fg);
            height: 100px; overflow-y: scroll; border: 1px solid var(--border-color); background: var(--panel-bg); padding: 10px;
        }

        /* Theme toggle */
        .theme-toggle {
            position: fixed; top: 10px; right: 10px; z-index: 500;
            background: var(--panel-bg); color: var(--text-color);
            border: 1px solid var(--border-color); border-radius: 6px; padding: 6px 10px; font-size: 12px;
        }
    </style>
</head>
<body>

    <button id="themeToggle" class="theme-toggle" title="Theme">Auto</button>

    <div class="header">
        <div class="header-group header-left">
            <div style="display:flex; align-items:center;">
                <label style="width: auto;">Role:</label>
                <select id="roleSelect">
                    <option value="1">Air unit (1)</option>
                    <option value="0">Ground unit (0)</option>
                </select>
            </div>
            <div class="commit-hash" id="commitHash">Commit: ---</div>
            <button id="readBtn" class="btn-blue">Read FULL config</button>
        </div>

        <div class="header-group header-right">
            <button id="connectBtn">Connect</button>
            <div class="split" id="writeSplit">
                <button id="writeBtn" class="btn-green btn-main">Write</button>
                <button id="writeCaretBtn" class="btn-green btn-caret">▾</button>
                <div id="resetRow" class="dropdown-row">
                    <button id="resetBtn" class="btn-blue text-right">Reset to default</button>
                </div>
            </div>
            <button id="helpBtn" class="btn-blue" title="Help" style="padding:6px 10px; border-radius:50%; width:34px; height:34px; display:inline-flex; align-items:center; justify-content:center;">?</button>
        </div>
    </div>

    <div class="settings-block">
        <h3>Frodo settings</h3>
        <div class="settings-grid">
            <div class="col-aux">
                <div class="form-row">
                    <label>Sync_AUX:</label>
                    <select id="syncAuxSelect"></select>
                </div>
                <div class="form-row">
                    <label>Start/Stop AUX:</label>
                    <select id="stopAuxSelect"></select>
                </div>
            </div>
            <div class="col-time">
                <div class="form-row">
                    <label>Switch_latency:</label>
                    <input type="text" id="swLatencyInput" placeholder="...">
                </div>
                <div class="form-row">
                    <label>Time on freq:</label>
                    <input type="text" id="txTimeInput" placeholder="...">
                </div>
            </div>
        </div>
    </div>

    <div class="freq-block">
        <h3>Freq settings</h3>
        
        <div class="form-row" style="max-width: 600px; gap: 10px;">
            <label>VRX range:</label>
            <div class="range-inputs">
                <input type="number" id="vrxMin" value="4200">
                <span>-</span>
                <input type="number" id="vrxMax" value="4900">
            </div>
            <button id="randBtn" class="btn-blue" style="margin-left:auto;">Random</button>
        </div>

        <div class="viz-container" id="vizContainer">
            <canvas id="freqCanvas"></canvas>
            <div class="freq-popup" id="freqPopup">
                <span class="freq-label" id="popupLabel">0000</span>
                <div class="popup-btns">
                    <button class="btn-mini btn-vtx1" id="popupVtx1">VTX1</button>
                    <button class="btn-mini btn-vtx2" id="popupVtx2">VTX2</button>
                </div>
            </div>
        </div>

        <div class="form-row">
            <label>VTX1:</label>
            <div class="vtx-wrapper">
                <div class="vtx-display" id="vtx1Display"></div>
                <input type="text" class="vtx-input" id="vtx1Input" placeholder="4200 4250...">
            </div>
        </div>
        <div class="form-row">
            <label>VTX2:</label>
            <div class="vtx-wrapper">
                <div class="vtx-display" id="vtx2Display"></div>
                <input type="text" class="vtx-input" id="vtx2Input" placeholder="4200 4250...">
            </div>
        </div>
    </div>

    <div id="debugLog">Ready. Connect OTG adapter first!</div>

    <details id="cliPanel" style="margin-top: 12px;">
        <summary style="cursor:pointer; font-weight:600;">CLI commands</summary>
        <textarea id="cliTextarea" style="width:100%; height:120px; margin-top:8px; box-sizing:border-box; font-family:monospace; font-size:12px;"></textarea>
    </details>

    <script>
        // DOM Elements
        const connectBtn = document.getElementById('connectBtn');
        const commitHashLabel = document.getElementById('commitHash');
        const debugLog = document.getElementById('debugLog');
        const roleSelect = document.getElementById('roleSelect');
        const syncAuxSelect = document.getElementById('syncAuxSelect');
        const stopAuxSelect = document.getElementById('stopAuxSelect');
        const swLatencyInput = document.getElementById('swLatencyInput');
        const txTimeInput = document.getElementById('txTimeInput');
        
        const vrxMinInput = document.getElementById('vrxMin');
        const vrxMaxInput = document.getElementById('vrxMax');
        const randBtn = document.getElementById('randBtn');
        
        // VTX Rich Inputs
        const vtx1Input = document.getElementById('vtx1Input');
        const vtx1Display = document.getElementById('vtx1Display');
        const vtx2Input = document.getElementById('vtx2Input');
        const vtx2Display = document.getElementById('vtx2Display');

        // Split button elements
        const writeBtn = document.getElementById('writeBtn');
        const writeCaretBtn = document.getElementById('writeCaretBtn');
        const writeSplit = document.getElementById('writeSplit');
        const resetRow = document.getElementById('resetRow');
        const resetBtn = document.getElementById('resetBtn');
        const readBtn = document.getElementById('readBtn');
        
        // Visualizer Elements
        const vizContainer = document.getElementById('vizContainer');
        const canvas = document.getElementById('freqCanvas');
        const ctx = canvas.getContext('2d');
        const freqPopup = document.getElementById('freqPopup');
        const popupLabel = document.getElementById('popupLabel');
        const popupVtx1 = document.getElementById('popupVtx1');
        const popupVtx2 = document.getElementById('popupVtx2');
        const helpBtn = document.getElementById('helpBtn');

        // Random Generator Popup Elements (created dynamically)
        let randPopup, randOverlay, randModeAdd, randModeReplace, randExcl, randCount, randTargetV1, randTargetV2, randTargetBoth, randFillBtn, randCloseBtn;
        let helpOverlay, helpPopup, helpCloseBtn;

        // Logic Variables
        let port, writerStream, reader;
        let isConnected = false;
        let vtx1Freqs = [];
        let vtx2Freqs = [];
        let isPopupOpen = false;
        let selectedFreq = 0;

        // Init
        initAuxDropdowns();
        resizeCanvas();
        updateVtxDisplay(1);
        updateVtxDisplay(2);
        window.addEventListener('resize', resizeCanvas);
        initTheme();

        // --- 1. POPULATE AUX ---
        function initAuxDropdowns() {
            const auxOptions = [];
            for (let i = 4; i <= 15; i++) {
                // Keep sending original numeric values (4..15), but display as Ch5..Ch16
                const display = `Ch${i + 1}`;
                auxOptions.push(`<option value="${i}">${display}</option>`);
            }
            syncAuxSelect.innerHTML = auxOptions.join('');
            stopAuxSelect.innerHTML = auxOptions.join('');
        }

        // --- 2. CONNECT ---
        connectBtn.addEventListener('click', async () => {
            if (!navigator.serial) return alert("Web Serial API not supported.");
            try {
                port = await navigator.serial.requestPort({ 
                    filters: [
                        { usbVendorId: 0x0483 }, { usbVendorId: 0x10C4 }, 
                        { usbVendorId: 0x0403 }, { usbVendorId: 0x1A86 }, { usbVendorId: 0x2341 }
                    ] 
                });
                await port.open({ baudRate: 9600 });
                await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                writerStream = port.writable.getWriter();
                
                connectBtn.textContent = "Connected";
                connectBtn.classList.add("connected");
                connectBtn.disabled = true;
                isConnected = true;

                readLoop();
                runStartupSequence();
            } catch (err) {
                log(`Error: ${err.message}`);
            }
        });

        // Graceful cleanup and UI reset on disconnect/errors
        async function cleanupPort() {
            try { if (reader) { try { await reader.cancel(); } catch(_){} try { reader.releaseLock(); } catch(_){} reader = null; } } catch(_){}
            try { if (writerStream) { writerStream.releaseLock(); writerStream = null; } } catch(_){}
            try { if (port) { await port.close(); } } catch(_){}
        }

        function setDisconnectedUI(msg) {
            if (msg) log(msg);
            connectBtn.textContent = 'Connect';
            connectBtn.classList.remove('connected');
            connectBtn.disabled = false;
            isConnected = false;
        }

        if (navigator.serial) {
            navigator.serial.addEventListener('disconnect', async (event) => {
                // If the disconnected port is the one we used, clean up
                if (!port || (event.port && port !== event.port)) {
                    log('A serial device disconnected');
                    return;
                }
                await cleanupPort();
                setDisconnectedUI('Device disconnected');
            });
            navigator.serial.addEventListener('connect', () => {
                log('Serial device connected');
            });
        }

        // --- 3. WRITE ---
        writeBtn.addEventListener('click', async () => {
            if (!port || !writerStream) return alert("Not connected!");
            writeBtn.disabled = true; document.body.style.cursor = 'wait';
            
            try {
                const commands = getCommandsForWrite();
                for (const cmd of commands) {
                    await sendCommandAndWait(cmd);
                }
                alert("Settings saved!");
            } catch (e) { log(`Write Error: ${e}`); }
            finally { writeBtn.disabled = false; document.body.style.cursor = 'default'; }
        });

        // --- 4. STARTUP SEQUENCE ---
        async function runStartupSequence() {
            log("--- Reading Commit ---");
            let helpData = await sendCommandAndWait("help");
            if (!parseCommit(helpData)) {
                await new Promise(r => setTimeout(r, 400));
                helpData = await sendCommandAndWait("help");
                parseCommit(helpData);
            }
            log("Tip: Use Read to load settings");
        }

        async function readAllSettings() {
            if (!port || !writerStream) return alert("Not connected!");
            log("--- Reading Settings ---");
            try {
                parseValue(await sendCommandAndWait("set_role"), roleSelect, "Role");
                parseValue(await sendCommandAndWait("set_sync_rc_channel"), syncAuxSelect, "Sync_AUX");
                parseValue(await sendCommandAndWait("set_stop_rc_channel"), stopAuxSelect, "Stop_AUX");
                parseValue(await sendCommandAndWait("set_sw_latency"), swLatencyInput, "Latency");
                parseValue(await sendCommandAndWait("set_tx_time"), txTimeInput, "TX Time");
                parseVtxList(await sendCommandAndWait("set_vtx1_freq"), 1);
                parseVtxList(await sendCommandAndWait("set_vtx2_freq"), 2);
                log("--- Done ---");
                drawViz();
                updateCliTextarea();
            } catch (e) { log(`Read Error: ${e}`); }
        }

        // --- 5. PARSERS & UI UPDATE ---
        function parseCommit(text) {
            const match = text.match(/Commit\s+([0-9a-fA-F]+)/);
            if (match && match[1]) {
                commitHashLabel.textContent = `Commit: ${match[1].substring(0, 7)}`;
                return true;
            } return false;
        }

        function parseValue(text, element, label) {
            const matches = text.match(/(\d+)/g);
            if (matches && matches.length > 0) {
                element.value = matches[matches.length - 1];
                log(`Parsed ${label}: ${element.value}`);
            }
        }

        function parseVtxList(text, vtxNum) {
            const match = text.match(/frequencies \d+;\s*([\d\s]+)/);
            if (match && match[1]) {
                const list = match[1].trim().split(/\s+/).map(Number);
                if (vtxNum === 1) { vtx1Freqs = list; } 
                else { vtx2Freqs = list; }
                updateVtxDisplay(vtxNum);
                log(`Parsed VTX${vtxNum} List: [${list.length} items]`);
            }
        }

        // --- 6. RICH VTX DISPLAY LOGIC ---
        function updateVtxDisplay(vtxNum) {
            const list = (vtxNum === 1) ? vtx1Freqs : vtx2Freqs;
            const display = (vtxNum === 1) ? vtx1Display : vtx2Display;
            const input = (vtxNum === 1) ? vtx1Input : vtx2Input;
            const min = parseInt(vrxMinInput.value) || 0;
            const max = parseInt(vrxMaxInput.value) || 9999;

            input.value = list.join(' ');
            display.innerHTML = '';
            if(list.length === 0) {
                display.innerHTML = '<span class="freq-tag placeholder">Empty... click to edit</span>';
            } else {
                list.forEach(f => {
                    const span = document.createElement('span');
                    span.textContent = f;
                    span.className = 'freq-tag';
                    if (f < min || f > max) {
                        span.classList.add('out-range');
                        span.title = "Out of VRX Range";
                    }
                    display.appendChild(span);
                });
            }
        }

        function setupVtxSwap(display, input, vtxNum) {
            display.addEventListener('click', () => {
                display.classList.add('hidden');
                input.classList.add('active');
                input.focus();
            });

            input.addEventListener('blur', () => {
                const raw = input.value.trim();
                const newList = raw ? raw.split(/\s+/).map(Number).filter(n => !isNaN(n)) : [];
                if(vtxNum === 1) vtx1Freqs = newList;
                else vtx2Freqs = newList;
                updateVtxDisplay(vtxNum);
                display.classList.remove('hidden');
                input.classList.remove('active');
                drawViz();
                updateCliTextarea();
            });
        }
        setupVtxSwap(vtx1Display, vtx1Input, 1);
        setupVtxSwap(vtx2Display, vtx2Input, 2);

        function checkRanges() {
            updateVtxDisplay(1);
            updateVtxDisplay(2);
            drawViz();
            updateCliTextarea();
        }
        vrxMinInput.addEventListener('input', checkRanges);
        vrxMaxInput.addEventListener('input', checkRanges);

        // --- 7. COMMS (Faster Timings) ---
        let currentResponseBuffer = "";
        async function sendCommandAndWait(cmd) {
            currentResponseBuffer = ""; 
            await sendSlow(cmd);
            await new Promise(r => setTimeout(r, 300)); 
            return currentResponseBuffer;
        }
        async function sendSlow(cmd) {
            log(`> Sending: ${cmd}`);
            const encoder = new TextEncoder();
            for (let i = 0; i < cmd.length; i++) {
                await writerStream.write(encoder.encode(cmd[i]));
                await new Promise(r => setTimeout(r, 10)); 
            }
            await writerStream.write(encoder.encode("\r"));
        }
        async function readLoop() {
            reader = port.readable.getReader();
            const decoder = new TextDecoder();
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    if (value) currentResponseBuffer += decoder.decode(value, { stream: true });
                }
            } catch (e) {
                console.error(e);
                await cleanupPort();
                setDisconnectedUI('Serial read stopped');
            } finally {
                try { reader.releaseLock(); } catch(_){}
            }
        }
        function log(msg) {
            const line = document.createElement('div');
            line.textContent = msg;
            debugLog.appendChild(line);
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // --- 8. VISUALIZER & RULER ---
        function resizeCanvas() {
            // Handle High-DPI for crisp ruler
            const dpr = window.devicePixelRatio || 1;
            const rect = vizContainer.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            ctx.scale(dpr, dpr);
            drawViz();
        }

        function drawViz() {
            const rect = vizContainer.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;

            // Layout Dimensions
            const frameH = 40; // Height of the "Frame" (Bar area)
            const textY = 54;  // Y position for text

            // Clear canvas
            ctx.clearRect(0, 0, w, h);

            const min = parseInt(vrxMinInput.value) || 4200;
            const max = parseInt(vrxMaxInput.value) || 4900;
            const range = max - min;
            
            // 1. Draw The "Visualisation Frame" (Background & Border)
            const cssVars = getComputedStyle(document.documentElement);
            const frameBg = cssVars.getPropertyValue('--frame-bg').trim() || '#fafafa';
            const frameBorder = cssVars.getPropertyValue('--frame-border').trim() || '#ccc';
            const rulerTick = cssVars.getPropertyValue('--ruler-tick').trim() || '#999';
            const rulerText = cssVars.getPropertyValue('--ruler-text').trim() || '#666';
            const baselineColor = cssVars.getPropertyValue('--baseline-color').trim() || '#ddd';

            ctx.fillStyle = frameBg;
            ctx.fillRect(0, 0, w, frameH);
            
            ctx.strokeStyle = frameBorder;
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, w, frameH);

            // 2. Draw Ruler (Ticks & Text BELOW frame)
            if (range > 0) {
                ctx.strokeStyle = rulerTick;
                ctx.fillStyle = rulerText;
                ctx.font = '10px sans-serif';

                const startTick = Math.ceil(min / 100) * 100;

                for (let f = startTick; f <= max; f += 100) {
                    const pct = (f - min) / range;
                    if (pct < 0 || pct > 1) continue;

                    const x = pct * w;

                    // Draw Tick (Connecting frame to text)
                    ctx.beginPath();
                    ctx.moveTo(x, frameH);     // Start at bottom of frame
                    ctx.lineTo(x, frameH + 6); // Draw 6px down
                    ctx.stroke();

                    // --- ALIGNMENT LOGIC ---
                    // If at start (0%), align Left
                    // If at end (100%), align Right
                    // Otherwise, Center
                    if (Math.abs(pct) < 0.001) {
                        ctx.textAlign = 'left';
                    } else if (Math.abs(pct - 1) < 0.001) {
                        ctx.textAlign = 'right';
                    } else {
                        ctx.textAlign = 'center';
                    }

                    // Draw Text
                    ctx.fillText(f, x, textY);
                }
            }

            // 3. Draw Center Baseline (Inside Frame)
            ctx.strokeStyle = baselineColor; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            ctx.moveTo(0, frameH/2); 
            ctx.lineTo(w, frameH/2); 
            ctx.stroke();

            // 4. Draw VTX1 Markers (Blue - Above Baseline)
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--vtx1-color').trim();
            vtx1Freqs.forEach(f => {
                if(f < min || f > max) return;
                const x = (f - min) / range * w;
                ctx.beginPath(); 
                ctx.moveTo(x, frameH/2 - 4); 
                ctx.lineTo(x - 5, frameH/2 - 14); 
                ctx.lineTo(x + 5, frameH/2 - 14); 
                ctx.fill();
            });

            // 5. Draw VTX2 Markers (Green - Below Baseline)
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--vtx2-color').trim();
            vtx2Freqs.forEach(f => {
                if(f < min || f > max) return;
                const x = (f - min) / range * w;
                ctx.beginPath(); 
                ctx.moveTo(x, frameH/2 + 4); 
                ctx.lineTo(x - 5, frameH/2 + 14); 
                ctx.lineTo(x + 5, frameH/2 + 14); 
                ctx.fill();
            });
        }

        // Mapping Logic for Click Interaction
        function getFreqFromX(x) {
            const min = parseInt(vrxMinInput.value) || 4200;
            const max = parseInt(vrxMaxInput.value) || 4900;
            const drawW = vizContainer.offsetWidth; // No margin substraction
            let pct = x / drawW;
            return Math.round(min + (Math.max(0, Math.min(1, pct)) * (max - min)));
        }

        // Canvas Interactions
        canvas.addEventListener('mousemove', (e) => {
            if(isPopupOpen) return;
            const rect = canvas.getBoundingClientRect();
            const freq = getFreqFromX(e.clientX - rect.left);
            freqPopup.style.display = 'block';
            freqPopup.style.left = (e.clientX - rect.left) + 'px';
            freqPopup.style.top = '10px'; 
            popupLabel.textContent = freq;
            popupVtx1.style.display = 'none'; popupVtx2.style.display = 'none';
        });
        canvas.addEventListener('mouseleave', () => { if(!isPopupOpen) freqPopup.style.display = 'none'; });
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            selectedFreq = getFreqFromX(e.clientX - rect.left);
            isPopupOpen = true;
            freqPopup.style.display = 'block';
            freqPopup.style.left = (e.clientX - rect.left) + 'px';
            freqPopup.style.top = '0px'; 
            popupLabel.textContent = selectedFreq;
            popupVtx1.style.display = 'inline-block'; popupVtx2.style.display = 'inline-block';
            if(vtx1Freqs.includes(selectedFreq)) popupVtx1.classList.add('active'); else popupVtx1.classList.remove('active');
            if(vtx2Freqs.includes(selectedFreq)) popupVtx2.classList.add('active'); else popupVtx2.classList.remove('active');
        });
        document.addEventListener('click', (e) => {
            if(e.target !== canvas && !freqPopup.contains(e.target)) { isPopupOpen = false; freqPopup.style.display = 'none'; }
        });
        
        function toggleFreq(vtxNum) {
            let list = (vtxNum === 1) ? vtx1Freqs : vtx2Freqs;
            const idx = list.indexOf(selectedFreq);
            if(idx > -1) list.splice(idx, 1); else list.push(selectedFreq);
            updateVtxDisplay(vtxNum);
            if(vtxNum===1) popupVtx1.classList.toggle('active'); else popupVtx2.classList.toggle('active');
            drawViz();
            updateCliTextarea();
        }
        popupVtx1.addEventListener('click', () => toggleFreq(1));
        popupVtx2.addEventListener('click', () => toggleFreq(2));
        
        writeCaretBtn.addEventListener('click', (e) => { e.stopPropagation(); resetRow.classList.toggle('show'); });
        document.addEventListener('click', () => resetRow.classList.remove('show'));
        readBtn.addEventListener('click', async () => {
            await readAllSettings();
        });
        resetBtn.addEventListener('click', (e) => { 
            e.stopPropagation();
            resetRow.classList.remove('show'); 
            log("Reset not implemented"); 
        });

        // --- 9. RANDOM GENERATOR POPUP ---
        function createRandPopupIfNeeded() {
            if (randPopup) return;

            // Overlay
            randOverlay = document.createElement('div');
            randOverlay.className = 'overlay';
            document.body.appendChild(randOverlay);

            // Popup
            randPopup = document.createElement('div');
            randPopup.className = 'rand-popup';
            randPopup.innerHTML = `
                <div class="rand-header">
                    <span>Generate VTX channels</span>
                    <button class="btn-blue" id="randCloseBtn" style="background:#999;">✕</button>
                </div>
                <div class="rand-body">
                    <div class="rand-row">
                        <label>Mode:</label>
                        <div class="grow">
                            <label><input type="radio" name="randMode" id="randModeAdd" value="add" checked> Add</label>
                            <label style="margin-left:16px;"><input type="radio" name="randMode" id="randModeReplace" value="replace"> Replace</label>
                        </div>
                    </div>
                    <div class="rand-row">
                        <label>Target:</label>
                        <div class="grow">
                            <label><input type="radio" name="randTarget" id="randTargetV1" value="v1"> VTX1</label>
                            <label style="margin-left:16px;"><input type="radio" name="randTarget" id="randTargetV2" value="v2"> VTX2</label>
                            <label style="margin-left:16px;"><input type="radio" name="randTarget" id="randTargetBoth" value="both" checked> Both</label>
                        </div>
                    </div>
                    <div class="rand-row" style="align-items:flex-start;">
                        <label>I got harmonics on:</label>
                        <div class="grow">
                            <textarea id="randExcl" class="rand-textarea" placeholder="Examples: 4444-4500  4444..4500  4444...4500  4444 4445 4446\nAlso supported: 4444 to 4500, 4444—4500 (dash), comma/space separated."></textarea>
                            <div class="rand-note">These frequencies will be EXCLUDED from randomization. Ranges can use -, .., ..., en-dash, or "to".</div>
                        </div>
                    </div>
                    <div class="rand-row">
                        <label>Desired number of channels:</label>
                        <div class="grow">
                            <textarea id="randCount" class="rand-textarea" style="min-height:34px; height:34px;"></textarea>
                            <div class="rand-note">Only digits are used; other characters will be ignored.</div>
                        </div>
                    </div>
                </div>
                <div class="rand-footer">
                    <button class="btn-blue" id="randFillBtn">Fill</button>
                </div>
            `;
            document.body.appendChild(randPopup);

            // Hook controls
            randModeAdd = randPopup.querySelector('#randModeAdd');
            randModeReplace = randPopup.querySelector('#randModeReplace');
            randExcl = randPopup.querySelector('#randExcl');
            randCount = randPopup.querySelector('#randCount');
            randTargetV1 = randPopup.querySelector('#randTargetV1');
            randTargetV2 = randPopup.querySelector('#randTargetV2');
            randTargetBoth = randPopup.querySelector('#randTargetBoth');
            randFillBtn = randPopup.querySelector('#randFillBtn');
            randCloseBtn = randPopup.querySelector('#randCloseBtn');

            randCloseBtn.addEventListener('click', closeRandPopup);
            randOverlay.addEventListener('click', closeRandPopup);
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeRandPopup(); });
            randCount.addEventListener('input', () => {
                // keep only digits
                const digits = (randCount.value.match(/\d+/g) || []).join('');
                if (randCount.value !== digits) randCount.value = digits;
            });
            randFillBtn.addEventListener('click', onRandFill);
        }

        function openRandPopup() {
            createRandPopupIfNeeded();
            randOverlay.classList.add('show');
            randPopup.classList.add('show');
        }
        function closeRandPopup() {
            if (!randPopup) return;
            randOverlay.classList.remove('show');
            randPopup.classList.remove('show');
        }

        function parseExclusions(input, min, max) {
            const set = new Set();
            if (!input) return set;
            const tokens = input
                .replace(/[,;\n]+/g, ' ') // normalize separators
                .trim()
                .split(/\s+/);
            for (const t of tokens) {
                if (!t) continue;
                // Normalize range separators
                const norm = t.replace(/…|–|—/g, '-') // ellipsis/en/em dash to '-'
                              .replace(/\.{2,}/g, '-') // .. or ... to '-'
                              .toLowerCase();
                if (/^\d+\s*(to|-)+\s*\d+$/.test(norm)) {
                    const parts = norm.split(/to|-+/);
                    let a = parseInt(parts[0], 10), b = parseInt(parts[1], 10);
                    if (Number.isFinite(a) && Number.isFinite(b)) {
                        if (a > b) [a, b] = [b, a];
                        a = Math.max(a, min); b = Math.min(b, max);
                        for (let v = a; v <= b; v++) set.add(v);
                    }
                } else if (/^\d+$/.test(norm)) {
                    const v = parseInt(norm, 10);
                    if (v >= min && v <= max) set.add(v);
                }
                // Everything else ignored silently
            }
            return set;
        }

        function generateRandomNonAdjacent(count, min, max, excludeSet) {
            // Build pool of allowed freqs
            const pool = [];
            for (let v = min; v <= max; v++) {
                if (!excludeSet.has(v)) pool.push(v);
            }
            if (pool.length === 0) return [];
            // Shuffle pool for randomness
            for (let i = pool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }
            const picked = [];
            const pickedSet = new Set();
            for (const v of pool) {
                if (picked.length >= count) break;
                // avoid immediate neighbors (no consecutive values)
                if (pickedSet.has(v) || pickedSet.has(v - 1) || pickedSet.has(v + 1)) continue;
                picked.push(v);
                pickedSet.add(v);
            }
            // Keep randomized order (do not sort) to avoid "consecutive hundreds" visual effect
            return picked;
        }

        function unionUniquePreserve(a, b) {
            const seen = new Set();
            const out = [];
            function pushIfNew(x){ if(!seen.has(x)){ seen.add(x); out.push(x);} }
            a.forEach(pushIfNew);
            b.forEach(pushIfNew);
            return out;
        }

        function onRandFill() {
            const min = parseInt(vrxMinInput.value) || 0;
            const max = parseInt(vrxMaxInput.value) || 0;
            if (!(max > min)) { alert('Invalid VRX range'); return; }

            const excl = parseExclusions(randExcl.value, min, max);
            const desired = parseInt((randCount.value || '0'), 10) || 0;
            if (desired <= 0) { alert('Enter desired number of channels (positive number)'); return; }

            const list = generateRandomNonAdjacent(desired, min, max, excl);
            if (list.length === 0) { alert('No available frequencies to choose from. Adjust range/exclusions.'); return; }
            if (list.length < desired) {
                log(`Warning: Only ${list.length} non-consecutive channels available within range and exclusions (requested ${desired}).`);
            }

            const mode = randModeReplace.checked ? 'replace' : 'add';
            const applyTo = randTargetBoth && randTargetBoth.checked ? 'both' : (randTargetV2 && randTargetV2.checked ? 'v2' : 'v1');

            function applyToOne(which, srcList) {
                if (which === 'v1') {
                    if (mode === 'replace') vtx1Freqs = srcList.slice();
                    else vtx1Freqs = unionUniquePreserve(vtx1Freqs, srcList);
                    updateVtxDisplay(1);
                } else if (which === 'v2') {
                    if (mode === 'replace') vtx2Freqs = srcList.slice();
                    else vtx2Freqs = unionUniquePreserve(vtx2Freqs, srcList);
                    updateVtxDisplay(2);
                }
            }
            if (applyTo === 'both') {
                // Distribute almost evenly by alternating assignment
                const v1List = [];
                const v2List = [];
                list.forEach((v, i) => { (i % 2 === 0 ? v1List : v2List).push(v); });
                applyToOne('v1', v1List);
                applyToOne('v2', v2List);
            } else {
                applyToOne(applyTo, list);
            }

            drawViz();
            updateCliTextarea();
            closeRandPopup();
        }

        randBtn.addEventListener('click', (e) => {
            e.preventDefault();
            openRandPopup();
        });

        // --- 10. HELP MODAL ---
        function createHelpModalIfNeeded() {
            if (helpPopup) return;
            // Overlay
            helpOverlay = document.createElement('div');
            helpOverlay.className = 'overlay';
            document.body.appendChild(helpOverlay);

            // Popup (reuse rand-popup styles)
            helpPopup = document.createElement('div');
            helpPopup.className = 'rand-popup';
            helpPopup.style.maxHeight = '80vh';
            helpPopup.style.overflow = 'hidden';
            helpPopup.innerHTML = `
                <div class="rand-header">
                    <span>Опис команд терміналу</span>
                    <button class="btn-blue" id="helpCloseBtn" style="background:#999;">✕</button>
                </div>
                <div class="rand-body" style="overflow:auto; max-height:calc(80vh - 110px);">
                    <details open>
                        <summary><strong>help</strong></summary>
                        <p><em>Призначення</em><br>Команда відображає службову інформацію прошивки (commit) та повний список доступних команд CLI з короткими описами кожної.</p>
                        <p><em>Використання</em><br>Виконується без аргументів.<br>Приклад: <code>help</code></p>
                        <p><em>Результат</em><br>виводиться рядок типу <code>Commit c01aa72;</code> далі — перелік усіх команд (set_guard_time, set_role, set_tx_time, set_vtx1_freq тощо) та їх коротких описів.</p>
                    </details>
                    <details>
                        <summary><strong>set_guard_time</strong></summary>
                        <p><em>Призначення</em><br>Встановлює додатковий «запас» часу (safety buffer / paranoia), який додається до основного часу перемикання частоти.</p>
                        <p><em>Використання</em><br>Без аргументів — показує поточне значення: <code>set_guard_time</code><br>З аргументом (мс) — встановлює нове: <code>set_guard_time 30</code></p>
                        <p><em>Примітки</em><br>Типове значення — близько 20 мс. Занадто великий guard_time збільшує цикл хопінгу.</p>
                    </details>
                    <details>
                        <summary><strong>set_role</strong></summary>
                        <p><em>Призначення</em><br>Роль пристрою: ground або air.</p>
                        <p><em>Використання</em><br>Без аргументів — показ поточного значення: <code>set_role</code><br>З аргументом — встановлення: <code>set_role 0</code> (ground), <code>set_role 1</code> (air)</p>
                        <p><em>Примітки</em><br>Пара має бути налаштована як ground/air відповідно.</p>
                    </details>
                    <details>
                        <summary><strong>set_stop_rc_channel</strong></summary>
                        <p><em>Призначення</em><br>Вибір RC‑каналу для команди «зупинки» хопінгу/передачі.</p>
                        <p><em>Використання</em><br>Показ: <code>set_stop_rc_channel</code><br>Встановлення: <code>set_stop_rc_channel 9</code></p>
                        <p><em>Примітки</em><br>Інтерпретація стану каналу залежить від прошивки.</p>
                    </details>
                    <details>
                        <summary><strong>set_sw_latency</strong></summary>
                        <p><em>Призначення</em><br>Задає апаратну затримку перемикання частоти (мс).</p>
                        <p><em>Використання</em><br>Показ: <code>set_sw_latency</code><br>Встановлення: <code>set_sw_latency 150</code></p>
                        <p><em>Примітки</em><br>Типово ~100 мс. Замале/завелике значення впливає на стабільність/швидкість хопінгу.</p>
                    </details>
                    <details>
                        <summary><strong>set_sync_rc_channel</strong></summary>
                        <p><em>Призначення</em><br>RC‑канал для синхронізації або додаткового керування режимом.</p>
                        <p><em>Використання</em><br>Показ: <code>set_sync_rc_channel</code><br>Встановлення: <code>set_sync_rc_channel 5</code></p>
                    </details>
                    <details>
                        <summary><strong>set_tx_time</strong></summary>
                        <p><em>Призначення</em><br>Тривалість перебування на частоті під час хопінгу (мс).</p>
                        <p><em>Використання</em><br>Показ: <code>set_tx_time</code><br>Встановлення: <code>set_tx_time 2500</code></p>
                        <p><em>Примітки</em><br>Мінімум: <code>sw_latency + guard_time</code>. Більший час — довші слоти, повільніший обхід.</p>
                    </details>
                    <details>
                        <summary><strong>set_vtx1_freq</strong></summary>
                        <p><em>Призначення</em><br>Список робочих частот для VTX1.</p>
                        <p><em>Використання</em><br>Показ: <code>set_vtx1_freq</code><br>Встановлення: <code>set_vtx1_freq 4200 4250 4300 ...</code></p>
                        <p><em>Примітки</em><br>Частоти мають бути у дозволеному діапазоні вашого VTX.</p>
                    </details>
                    <details>
                        <summary><strong>set_vtx2_freq</strong></summary>
                        <p><em>Призначення</em><br>Аналогічно до VTX1, але для VTX2.</p>
                        <p><em>Використання</em><br>Показ: <code>set_vtx2_freq</code><br>Встановлення: <code>set_vtx2_freq 4500 4550 4600 ...</code></p>
                    </details>
                </div>
                <div class="rand-footer">
                    <button class="btn-blue" id="helpCloseBtn2">Close</button>
                </div>
            `;
            document.body.appendChild(helpPopup);

            helpCloseBtn = helpPopup.querySelector('#helpCloseBtn');
            const helpCloseBtn2 = helpPopup.querySelector('#helpCloseBtn2');

            const close = () => closeHelpModal();
            helpCloseBtn.addEventListener('click', close);
            helpCloseBtn2.addEventListener('click', close);
            helpOverlay.addEventListener('click', close);
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') close(); });
        }

        function openHelpModal() {
            createHelpModalIfNeeded();
            helpOverlay.classList.add('show');
            helpPopup.classList.add('show');
        }
        function closeHelpModal() {
            if (!helpPopup) return;
            helpOverlay.classList.remove('show');
            helpPopup.classList.remove('show');
        }

        helpBtn.addEventListener('click', (e) => { e.preventDefault(); openHelpModal(); });

        // THEME HANDLING
        function applyTheme(mode) {
            const root = document.documentElement;
            if (mode === 'light') {
                root.setAttribute('data-theme', 'light');
            } else if (mode === 'dark') {
                root.setAttribute('data-theme', 'dark');
            } else {
                root.removeAttribute('data-theme');
            }
            const btn = document.getElementById('themeToggle');
            if (btn) btn.textContent = (mode === 'light' ? 'Light' : mode === 'dark' ? 'Dark' : 'Auto');
            drawViz();
        }
        function initTheme() {
            const saved = localStorage.getItem('frodo_theme') || 'auto';
            applyTheme(saved);
            const btn = document.getElementById('themeToggle');
            if (btn) btn.addEventListener('click', () => {
                const current = document.documentElement.getAttribute('data-theme') || 'auto';
                const next = current === 'auto' ? 'dark' : current === 'dark' ? 'light' : 'auto';
                localStorage.setItem('frodo_theme', next);
                applyTheme(next);
            });
        }
        // --- 9. CLI COMMANDS PANEL ---
        const cliTextarea = document.getElementById('cliTextarea');
        let cliProgrammatic = false;
        let cliParseTimer = null;
        let cliUserEditing = false;

        function getVrxRange() {
            const min = parseInt(vrxMinInput.value) || 0;
            const max = parseInt(vrxMaxInput.value) || 9999;
            return [min, max];
        }

        function buildCliCommands() {
            const cmds = [];
            cmds.push(`set_role ${roleSelect.value}`);
            cmds.push(`set_sync_rc_channel ${syncAuxSelect.value}`);
            cmds.push(`set_stop_rc_channel ${stopAuxSelect.value}`);
            if (swLatencyInput.value) cmds.push(`set_sw_latency ${swLatencyInput.value}`);
            if (txTimeInput.value) cmds.push(`set_tx_time ${txTimeInput.value}`);
            // Always include guard time as 20 (hidden from UI)
            cmds.push(`set_guard_time 20`);

            const [min, max] = getVrxRange();
            const validVtx1 = (vtx1Freqs || []).filter(f => f >= min && f <= max);
            const validVtx2 = (vtx2Freqs || []).filter(f => f >= min && f <= max);
            if (validVtx1.length > 0) cmds.push(`set_vtx1_freq ${validVtx1.join(' ')}`);
            if (validVtx2.length > 0) cmds.push(`set_vtx2_freq ${validVtx2.join(' ')}`);
            return cmds;
        }

        function updateCliTextarea() {
            if (!cliTextarea) return;
            cliProgrammatic = true;
            cliTextarea.value = buildCliCommands().join('\n');
            cliProgrammatic = false;
        }

        function getCommandsForWrite() {
            const allowed = [
                'set_role',
                'set_sync_rc_channel',
                'set_stop_rc_channel',
                'set_sw_latency',
                'set_tx_time',
                'set_vtx1_freq',
                'set_vtx2_freq',
                'set_guard_time'
            ];
            const lines = (cliTextarea?.value || '').split(/\r?\n/)
                .map(s => s.trim())
                .filter(Boolean)
                .filter(s => allowed.some(a => s.startsWith(a)));

            // Remove any custom guard time and enforce 20
            const filtered = lines.filter(l => !l.startsWith('set_guard_time'));
            filtered.push('set_guard_time 20');
            return filtered;
        }

        function parseCliTextarea() {
            const lines = cliTextarea.value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
            let newVtx1 = null, newVtx2 = null;
            for (const line of lines) {
                if (/^set_role\s+/.test(line)) {
                    const m = line.match(/^set_role\s+(\d+)/);
                    if (m) roleSelect.value = m[1];
                } else if (/^set_sync_rc_channel\s+/.test(line)) {
                    const m = line.match(/^set_sync_rc_channel\s+(\d+)/);
                    if (m) syncAuxSelect.value = m[1];
                } else if (/^set_stop_rc_channel\s+/.test(line)) {
                    const m = line.match(/^set_stop_rc_channel\s+(\d+)/);
                    if (m) stopAuxSelect.value = m[1];
                } else if (/^set_sw_latency\s+/.test(line)) {
                    const m = line.match(/^set_sw_latency\s+(\d+)/);
                    if (m) swLatencyInput.value = m[1];
                } else if (/^set_tx_time\s+/.test(line)) {
                    const m = line.match(/^set_tx_time\s+(\d+)/);
                    if (m) txTimeInput.value = m[1];
                } else if (/^set_vtx1_freq\s+/.test(line)) {
                    const nums = line.replace(/^set_vtx1_freq\s+/, '').trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
                    newVtx1 = nums;
                } else if (/^set_vtx2_freq\s+/.test(line)) {
                    const nums = line.replace(/^set_vtx2_freq\s+/, '').trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
                    newVtx2 = nums;
                }
                // set_guard_time is intentionally ignored in UI (fixed to 20)
            }
            if (newVtx1 !== null) vtx1Freqs = newVtx1;
            if (newVtx2 !== null) vtx2Freqs = newVtx2;
            updateVtxDisplay(1);
            updateVtxDisplay(2);
            drawViz();
        }

        // Keep CLI in sync when UI changes
        function maybeUpdateCli() { if (!cliUserEditing) updateCliTextarea(); }
        roleSelect.addEventListener('change', maybeUpdateCli);
        syncAuxSelect.addEventListener('change', maybeUpdateCli);
        stopAuxSelect.addEventListener('change', maybeUpdateCli);
        swLatencyInput.addEventListener('input', maybeUpdateCli);
        txTimeInput.addEventListener('input', maybeUpdateCli);

        cliTextarea.addEventListener('input', () => {
            if (cliProgrammatic) return;
            if (cliParseTimer) clearTimeout(cliParseTimer);
            cliParseTimer = setTimeout(() => {
                parseCliTextarea();
            }, 300);
        });

        cliTextarea.addEventListener('focus', () => { cliUserEditing = true; });
        cliTextarea.addEventListener('blur', () => { 
            cliUserEditing = false; 
            updateCliTextarea();
        });

        // Initialize CLI with current defaults
        updateCliTextarea();

    </script>
</body>
</html>
